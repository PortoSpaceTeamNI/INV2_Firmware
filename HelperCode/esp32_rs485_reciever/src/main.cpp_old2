#include <SPI.h>
#include <SerialFlash.h>

#define FLASH_POWER_PIN 15  // Pin controlling the power to the flash memory
#define FLASH_CS_PIN 5    // Chip Select pin for the SPI flash

SerialFlashFile file;

bool initializeFlash() {
  return SerialFlash.begin(FLASH_CS_PIN);
}

void powerCycleFlash() {
  Serial.println("Power cycling SPI flash memory...");

  // Turn off power to the flash memory
  digitalWrite(FLASH_POWER_PIN, LOW);
  delay(100);  // Wait for 100ms

  // Turn on power to the flash memory
  digitalWrite(FLASH_POWER_PIN, HIGH);
  delay(100);  // Wait for 100ms to stabilize

  Serial.println("SPI flash memory power cycled.");
}

const char * id2chip(const unsigned char *id)
{
	if (id[0] == 0xEF) {
		// Winbond
		if (id[1] == 0x40) {
			if (id[2] == 0x14) return "W25Q80BV";
			if (id[2] == 0x15) return "W25Q16DV";
			if (id[2] == 0x17) return "W25Q64FV";
			if (id[2] == 0x18) return "W25Q128FV";
			if (id[2] == 0x19) return "W25Q256FV";
		}
	}
	if (id[0] == 0x01) {
		// Spansion
		if (id[1] == 0x02) {
			if (id[2] == 0x16) return "S25FL064A";
			if (id[2] == 0x19) return "S25FL256S";
			if (id[2] == 0x20) return "S25FL512S";
		}
		if (id[1] == 0x20) {
			if (id[2] == 0x18) return "S25FL127S";
		}
	}
	if (id[0] == 0xC2) {
		// Macronix
		if (id[1] == 0x20) {
			if (id[2] == 0x18) return "MX25L12805D";
		}
	}
	if (id[0] == 0x20) {
		// Micron
		if (id[1] == 0xBA) {
			if (id[2] == 0x20) return "N25Q512A";
			if (id[2] == 0x21) return "N25Q00AA";
		}
		if (id[1] == 0xBB) {
			if (id[2] == 0x22) return "MT25QL02GC";
		}
	}
	if (id[0] == 0xBF) {
		// SST
		if (id[1] == 0x25) {
			if (id[2] == 0x02) return "SST25WF010";
			if (id[2] == 0x03) return "SST25WF020";
			if (id[2] == 0x04) return "SST25WF040";
			if (id[2] == 0x41) return "SST25VF016B";
			if (id[2] == 0x4A) return "SST25VF032";
		}
		if (id[1] == 0x25) {
			if (id[2] == 0x01) return "SST26VF016";
			if (id[2] == 0x02) return "SST26VF032";
			if (id[2] == 0x43) return "SST26VF064";
		}
	}
  	if (id[0] == 0x1F) {
    		// Adesto
   		if (id[1] == 0x89) {
      			if (id[2] == 0x01) return "AT25SF128A";
    		}  
  	} 	
	return "(unknown chip)";
}

void setup() {
  Serial.begin(115200);

  unsigned char buf[256], sig[256], buf2[8];
  unsigned long address, count, chipsize, blocksize;
  unsigned long usec;
  bool first;

  pinMode(FLASH_POWER_PIN, OUTPUT);

  // Ensure power is on initially
  digitalWrite(FLASH_POWER_PIN, HIGH);
  delay(100);  // Wait for the power to stabilize

  //Initialize the flash memory
  if (initializeFlash()) {
    Serial.println("Flash memory initialized successfully.");
  } else {
    Serial.println("Failed to initialize flash memory.");
  }

  // Read the chip identification
  Serial.println();
  Serial.println(F("Read Chip Identification:"));
  SerialFlash.readID(buf);
  Serial.print(F("  JEDEC ID:     "));
  Serial.print(buf[0], HEX);
  Serial.print(' ');
  Serial.print(buf[1], HEX);
  Serial.print(' ');
  Serial.println(buf[2], HEX);
  Serial.print(F("  Part Number: "));
  Serial.println(id2chip(buf));
  Serial.print(F("  Memory Size:  "));
  chipsize = SerialFlash.capacity(buf);
  Serial.print(chipsize);
  Serial.println(F(" bytes"));

  // Example power cycle
  //powerCycleFlash();

  // Reinitialize after power cycle
  if (initializeFlash()) {
    Serial.println("Flash memory reinitialized successfully after power cycle.");
  } else {
    Serial.println("Failed to reinitialize flash memory after power cycle.");
  }

// Read the chip identification
  Serial.println();
  Serial.println(F("Read Chip Identification:"));
  SerialFlash.readID(buf);
  Serial.print(F("  JEDEC ID:     "));
  Serial.print(buf[0], HEX);
  Serial.print(' ');
  Serial.print(buf[1], HEX);
  Serial.print(' ');
  Serial.println(buf[2], HEX);
  Serial.print(F("  Part Number: "));
  Serial.println(id2chip(buf));
  Serial.print(F("  Memory Size:  "));
  chipsize = SerialFlash.capacity(buf);
  Serial.print(chipsize);
  Serial.println(F(" bytes"));
}

void loop() {
  // Your main code
}

